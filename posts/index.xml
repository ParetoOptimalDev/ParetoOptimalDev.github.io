<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Pareto Optimal Dev</title><link>https://paretooptimaldev.github.io/posts/</link><description>Recent content in Posts on Pareto Optimal Dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://paretooptimaldev.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>"Simple Haskell" can result in simple code but complex codebases</title><link>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</guid><description>Related Prefer macro-level simplicity even if it means micro-level complexity Haskell</description></item><item><title>Categorizing state/quality of notes with tags and the real life tree lifecycle</title><link>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</guid><description>It can be useful to look at the &amp;ldquo;timelines&amp;rdquo;, &amp;ldquo;maturity of development&amp;rdquo;, or &amp;ldquo;doneness&amp;rdquo; of notes in an exobrain, zettlekasten, or digital garden given quality can vary widely.
Taking inspiration from Evergreen Notes we can use the following tree inspired cateories:
seed (aka stub elsewhere) stem sprout sapling tree evergreen This could be further augmented by using tags to delineate between polished and unpolished pieces of writing.
One example is an unpolished evergreen would have strong concepts and a well formed idea but the structure could be very messy or a little hard to follow.</description></item><item><title>Choosing "Fancy Haskell" can be for pragmatic reasons</title><link>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</guid><description>stuff Related &amp;ldquo;Simple Haskell&amp;rdquo; can result in simple code but complex codebases Related Haskell</description></item><item><title>emacs</title><link>https://paretooptimaldev.github.io/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/emacs/</guid><description/></item><item><title>Evergreen Notes</title><link>https://paretooptimaldev.github.io/evergreen-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/evergreen-notes/</guid><description>Evergreen notes are written and organized to evolve, contribute, and accumulate over time, across projects. This is an unusual way to think about writing notes: Most people take only transient notes. That’s because these practices aren’t about writing notes; they’re about effectively developing insight: “Better note-taking” misses the point; what matters is “better thinking”. When done well, these notes can be quite valuable: Evergreen note-writing as fundamental unit of knowledge work.</description></item><item><title>Haskell</title><link>https://paretooptimaldev.github.io/haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/haskell/</guid><description/></item><item><title>Literature: Delivering with Haskell</title><link>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</guid><description>https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597</description></item><item><title>NixOS</title><link>https://paretooptimaldev.github.io/nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nixos/</guid><description>:ID: 4d24c424-8b8b-4f35-97eb-ed8eee51f8ec</description></item><item><title>org-roam</title><link>https://paretooptimaldev.github.io/org-roam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/org-roam/</guid><description/></item><item><title>Pareto Optimality and software development</title><link>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</guid><description/></item><item><title>Personal Knowledge Management</title><link>https://paretooptimaldev.github.io/personal-knowledge-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/personal-knowledge-management/</guid><description/></item><item><title>Prefer macro-level simplicity even if it means micro-level complexity</title><link>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</guid><description>Related Haskell</description></item></channel></rss>