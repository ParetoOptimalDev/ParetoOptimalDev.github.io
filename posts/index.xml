<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Pareto Optimal Dev</title><link>https://paretooptimaldev.github.io/posts/</link><description>Recent content in Posts on Pareto Optimal Dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://paretooptimaldev.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>"Simple Haskell" can result in simple code but complex codebases</title><link>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</guid><description>Related Prefer macro-level simplicity even if it means micro-level complexity Haskell</description></item><item><title>Categorizing state/quality of notes with tags and the real life tree lifecycle</title><link>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</guid><description>It can be useful to look at the &amp;ldquo;timelines&amp;rdquo;, &amp;ldquo;maturity of development&amp;rdquo;, or &amp;ldquo;doneness&amp;rdquo; of notes in an exobrain, zettlekasten, or digital garden given quality can vary widely.
Taking inspiration from Evergreen Notes we can use the following tree inspired cateories:
seed (aka stub elsewhere) stem sprout sapling tree evergreen This could be further augmented by using tags to delineate between polished and unpolished pieces of writing.
One example is an unpolished evergreen would have strong concepts and a well formed idea but the structure could be very messy or a little hard to follow.</description></item><item><title>Choosing "Fancy Haskell" can be for pragmatic reasons</title><link>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</guid><description>stuff Related &amp;ldquo;Simple Haskell&amp;rdquo; can result in simple code but complex codebases Related Haskell</description></item><item><title>counteract my cognitive biases by playing devils advocate</title><link>https://paretooptimaldev.github.io/counteract-my-cognitive-biases-by-playing-devils-advocate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/counteract-my-cognitive-biases-by-playing-devils-advocate/</guid><description/></item><item><title>emacs</title><link>https://paretooptimaldev.github.io/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/emacs/</guid><description/></item><item><title>Evergreen Notes</title><link>https://paretooptimaldev.github.io/evergreen-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/evergreen-notes/</guid><description>Evergreen notes are written and organized to evolve, contribute, and accumulate over time, across projects. This is an unusual way to think about writing notes: Most people take only transient notes. That’s because these practices aren’t about writing notes; they’re about effectively developing insight: “Better note-taking” misses the point; what matters is “better thinking”. When done well, these notes can be quite valuable: Evergreen note-writing as fundamental unit of knowledge work.</description></item><item><title>examples of considering pareto optimality in software development</title><link>https://paretooptimaldev.github.io/examples-of-considering-pareto-optimality-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/examples-of-considering-pareto-optimality-in-software-development/</guid><description>Ease of use and type-safety of Haskell programs quote from the original quote that got me thinking about pareto optimality and software development Arguably, ease-of-use and type safety could be such a case. For a long time the Haskell community has had a lot of places to get &amp;ldquo;free&amp;rdquo; gains in both dimensions. But, it should be expected that if you get enough of these gains squared away, that eventually you will hit the point where they will become tradeoffs.</description></item><item><title>Haskell</title><link>https://paretooptimaldev.github.io/haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/haskell/</guid><description/></item><item><title>JUST SHIP IT!</title><link>https://paretooptimaldev.github.io/just-ship-it/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/just-ship-it/</guid><description/></item><item><title>keep it simple stupid</title><link>https://paretooptimaldev.github.io/keep-it-simple-stupid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/keep-it-simple-stupid/</guid><description/></item><item><title>Literature: Delivering with Haskell</title><link>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</guid><description>https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597</description></item><item><title>major cognitive biases in software development</title><link>https://paretooptimaldev.github.io/major-cognitive-biases-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/major-cognitive-biases-in-software-development/</guid><description/></item><item><title>NixOS</title><link>https://paretooptimaldev.github.io/nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nixos/</guid><description>:ID: 4d24c424-8b8b-4f35-97eb-ed8eee51f8ec</description></item><item><title>org-roam</title><link>https://paretooptimaldev.github.io/org-roam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/org-roam/</guid><description/></item><item><title>Pareto Optimality and software development</title><link>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</guid><description>Skip to examples of considering pareto optimality in software development context In brief, Pareto optimal solution is defined as a set of &amp;lsquo;non-inferior&amp;rsquo; solutions in the objective space defining a boundary beyond which none of the objectives can be improved without sacrificing at least one of the other objectives - https://www.sciencedirect.com/topics/engineering/pareto-optimality
In the context of software development, you&amp;rsquo;ll frequently hear about tradeoffs such as the adage:
&amp;ldquo;Good. Fast.</description></item><item><title>Personal Knowledge Management</title><link>https://paretooptimaldev.github.io/personal-knowledge-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/personal-knowledge-management/</guid><description/></item><item><title>Prefer macro-level simplicity even if it means micro-level complexity</title><link>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</guid><description>Related Haskell</description></item><item><title>Principle of Charity</title><link>https://paretooptimaldev.github.io/principle-of-charity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/principle-of-charity/</guid><description/></item><item><title>the original quote that got me thinking about pareto optimality and software development</title><link>https://paretooptimaldev.github.io/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</guid><description>quote One could make a case that what we&amp;rsquo;re seeing here is that Haskell web frameworks, and probably a great deal more of the real Haskell code the community has produced in the past few years, is reaching the Pareto optimality frontier between ease-of-use and type safety guarantees.
I imagine a lot of people know what that is given where I am :), but in short, Pareto-optimal means that if you are optimizing between two quantities, you can not increase one without decreasing the other.</description></item><item><title>vscode</title><link>https://paretooptimaldev.github.io/vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/vscode/</guid><description/></item><item><title>worse is better</title><link>https://paretooptimaldev.github.io/worse-is-better/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/worse-is-better/</guid><description/></item></channel></rss>