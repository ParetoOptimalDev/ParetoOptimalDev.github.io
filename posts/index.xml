<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Pareto Optimal Dev</title><link>https://paretooptimaldev.github.io/posts/</link><description>Recent content in Posts on Pareto Optimal Dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://paretooptimaldev.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>"Simple Haskell" can result in simple code but complex codebases</title><link>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/simple-haskell-can-result-in-simple-code-but-complex-codebases/</guid><description>Related Prefer macro-level simplicity even if it means micro-level complexity Haskell</description></item><item><title>boring haskell</title><link>https://paretooptimaldev.github.io/boring-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/boring-haskell/</guid><description/></item><item><title>brand of simplicity</title><link>https://paretooptimaldev.github.io/brand-of-simplicity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/brand-of-simplicity/</guid><description>I find that most arguments about simplicity aren&amp;rsquo;t based in objective truth, but rather treat subjective ideas as objective fact in order to allow an argument to be stronger than it actually is.
So brand of simplicity is a way to:
indicate something being called simple isn&amp;rsquo;t necessarily simple encourage thinking about other values or vectors in which the subject wouldn&amp;rsquo;t be simple Push towards thinking about Pareto Optimality For instance the Go claimed for a very long term to not have parametric polymorphism &amp;ldquo;cuz simplicity&amp;rdquo;.</description></item><item><title>Categorizing state/quality of notes with tags and the real life tree lifecycle</title><link>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</guid><description>It can be useful to look at the &amp;ldquo;timelines&amp;rdquo;, &amp;ldquo;maturity of development&amp;rdquo;, or &amp;ldquo;doneness&amp;rdquo; of notes in an exobrain, zettlekasten, or digital garden given quality can vary widely.
Taking inspiration from Evergreen Notes we can use the following tree inspired cateories:
seed (aka stub elsewhere) stem sprout sapling tree evergreen This could be further augmented by using tags to delineate between polished and unpolished pieces of writing.
One example is an unpolished evergreen would have strong concepts and a well formed idea but the structure could be very messy or a little hard to follow.</description></item><item><title>Choosing "Fancy Haskell" can be for pragmatic reasons</title><link>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</guid><description>stuff Related &amp;ldquo;Simple Haskell&amp;rdquo; can result in simple code but complex codebases Related Haskell</description></item><item><title>counteract my cognitive biases by playing devils advocate</title><link>https://paretooptimaldev.github.io/counteract-my-cognitive-biases-by-playing-devils-advocate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/counteract-my-cognitive-biases-by-playing-devils-advocate/</guid><description/></item><item><title>develop Haskell projects using NixOS</title><link>https://paretooptimaldev.github.io/develop-haskell-projects-using-nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/develop-haskell-projects-using-nixos/</guid><description/></item><item><title>emacs</title><link>https://paretooptimaldev.github.io/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/emacs/</guid><description/></item><item><title>Evergreen Notes</title><link>https://paretooptimaldev.github.io/evergreen-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/evergreen-notes/</guid><description>Evergreen notes are written and organized to evolve, contribute, and accumulate over time, across projects. This is an unusual way to think about writing notes: Most people take only transient notes. That’s because these practices aren’t about writing notes; they’re about effectively developing insight: “Better note-taking” misses the point; what matters is “better thinking”. When done well, these notes can be quite valuable: Evergreen note-writing as fundamental unit of knowledge work.</description></item><item><title>examples of considering pareto optimality in software development</title><link>https://paretooptimaldev.github.io/examples-of-considering-pareto-optimality-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/examples-of-considering-pareto-optimality-in-software-development/</guid><description>Ease of use and type-safety of Haskell programs quote from the original quote that got me thinking about pareto optimality and software development Arguably, ease-of-use and type safety could be such a case. For a long time the Haskell community has had a lot of places to get &amp;ldquo;free&amp;rdquo; gains in both dimensions. But, it should be expected that if you get enough of these gains squared away, that eventually you will hit the point where they will become tradeoffs.</description></item><item><title>Go</title><link>https://paretooptimaldev.github.io/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/go/</guid><description>The programming language that was proud of not having generics in their language for most of the languages life.</description></item><item><title>Haskell</title><link>https://paretooptimaldev.github.io/haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/haskell/</guid><description/></item><item><title>home-manager</title><link>https://paretooptimaldev.github.io/home-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/home-manager/</guid><description>Frequently used in conjunction with NixOS, it allows users to encode their dotfiles in their nix configuration either inline or by files in their NixOS configuration</description></item><item><title>JUST SHIP IT!</title><link>https://paretooptimaldev.github.io/just-ship-it/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/just-ship-it/</guid><description/></item><item><title>keep it simple stupid</title><link>https://paretooptimaldev.github.io/keep-it-simple-stupid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/keep-it-simple-stupid/</guid><description/></item><item><title>Literature: Abusing org-roam as a personal CRM - r/emacs</title><link>https://paretooptimaldev.github.io/literature-abusing-org-roam-as-a-personal-crm-r/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/literature-abusing-org-roam-as-a-personal-crm-r/emacs/</guid><description>I&amp;rsquo;ve found myself wanting to have the ability to see how other people use computers more effectively without committing half an hour or so to a video. So I tried to make a very short video showing how I use org-roam as a personal CRM. It isn&amp;rsquo;t a mind-blowing use-case, it isn&amp;rsquo;t any complex elisp, it is just a window into how I use Emacs to solve a problem that needed solving.</description></item><item><title>Literature: Delivering with Haskell</title><link>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/literature-delivering-with-haskell/</guid><description>https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597</description></item><item><title>major cognitive biases in software development</title><link>https://paretooptimaldev.github.io/major-cognitive-biases-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/major-cognitive-biases-in-software-development/</guid><description/></item><item><title>Managing your emacs configuration, system configuration, and all dependencies in a single org file</title><link>https://paretooptimaldev.github.io/managing-your-emacs-configuration-system-configuration-and-all-dependencies-in-a-single-org-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/managing-your-emacs-configuration-system-configuration-and-all-dependencies-in-a-single-org-file/</guid><description>WIP, this is just an outline so far
TODO Bootstrapping init.el to use an org file for what it believes is your &amp;ldquo;emacs configuration&amp;rdquo; TODO user level configuration using home-manager TODO configuring magit, including git as a system dependency, and .gitconfig in the same org heading</description></item><item><title>Nix flakes</title><link>https://paretooptimaldev.github.io/nix-flakes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nix-flakes/</guid><description>resources https://www.tweag.io/blog/2020-05-25-flakes/ https://serokell.io/blog/practical-nix-flakes (pretty accessible imo)</description></item><item><title>NixOS</title><link>https://paretooptimaldev.github.io/nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nixos/</guid><description/></item><item><title>NixOS configuration</title><link>https://paretooptimaldev.github.io/nixos-configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nixos-configuration/</guid><description>I&amp;rsquo;ll typically assume this means using Nix flakes, unless I think it&amp;rsquo;s 100% necessary to default to old-style non-flake configurations for accessibility such as in Package management and configuration in emacs where the audience might have never used NixOS.</description></item><item><title>NixOS has a steep learning curve</title><link>https://paretooptimaldev.github.io/nixos-has-a-steep-learning-curve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/nixos-has-a-steep-learning-curve/</guid><description/></item><item><title>org-roam</title><link>https://paretooptimaldev.github.io/org-roam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/org-roam/</guid><description/></item><item><title>Package management and configuration in emacs</title><link>https://paretooptimaldev.github.io/package-management-and-configuration-in-emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/package-management-and-configuration-in-emacs/</guid><description>What&amp;rsquo;s the best way to manage packages in emacs? I&amp;rsquo;ve tried quite a few and prefer
package.el (builtin) I used this until I ran into two problems:
Using packages not yet in elpa or melpa easily from github &amp;ldquo;https://elpa.gnu.org/packages/archive-contents&amp;rdquo; &amp;ldquo;Bad Request&amp;rdquo; Maybe now there are better solutions, but I moved on to straight.el
straight.el Straight worked well for me for some time, and I could really relate to parts of it&amp;rsquo;s readme given I was already into Haskell and NixOS:</description></item><item><title>Pareto Optimality and software development</title><link>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/pareto-optimality-and-software-development/</guid><description>Some may want to skip to examples of considering pareto optimality in software development
context In brief, Pareto optimal solution is defined as a set of &amp;lsquo;non-inferior&amp;rsquo; solutions in the objective space defining a boundary beyond which none of the objectives can be improved without sacrificing at least one of the other objectives - https://www.sciencedirect.com/topics/engineering/pareto-optimality
In the context of software development, you&amp;rsquo;ll frequently hear about tradeoffs such as the adage:</description></item><item><title>Personal Knowledge Management</title><link>https://paretooptimaldev.github.io/personal-knowledge-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/personal-knowledge-management/</guid><description/></item><item><title>Prefer macro-level simplicity even if it means micro-level complexity</title><link>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</guid><description>Related Haskell</description></item><item><title>Principle of Charity</title><link>https://paretooptimaldev.github.io/principle-of-charity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/principle-of-charity/</guid><description/></item><item><title>Replacing straight.el with Nix to manage emacs packages</title><link>https://paretooptimaldev.github.io/replacing-straight.el-with-nix-to-manage-emacs-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/replacing-straight.el-with-nix-to-manage-emacs-packages/</guid><description>Why? In short, for better reproducability and to free me from manual intervention because packages broke later.
For more details you can see my history of package.el -&amp;gt; straight.el -&amp;gt; Nix for managing emacs packages in Package management and configuration in emacs.
The simple case straight.el configuration early-init.el
(setq package-enable-at-startup nil) init.el
(defvar bootstrap-version) (let ((bootstrap-file (expand-file-name &amp;#34;straight/repos/straight.el/bootstrap.el&amp;#34; user-emacs-directory)) (bootstrap-version 5)) (unless (file-exists-p bootstrap-file) (with-current-buffer (url-retrieve-synchronously &amp;#34;https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el&amp;#34; &amp;#39;silent &amp;#39;inhibit-cookies) (goto-char (point-max)) (eval-print-last-sexp))) (load bootstrap-file nil &amp;#39;nomessage)) (setq straight-use-package-by-default t) (straight-use-package &amp;#39;use-package) (use-package magit) nix configuration early-init.</description></item><item><title>Should org-roam/zettlekasten be used only for concepts or also for more general data?</title><link>https://paretooptimaldev.github.io/should-org-roam/zettlekasten-be-used-only-for-concepts-or-also-for-more-general-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/should-org-roam/zettlekasten-be-used-only-for-concepts-or-also-for-more-general-data/</guid><description>I suppose if you&amp;rsquo;re following zettlekasten or especially Evergreen Notes, it&amp;rsquo;ll be more about developing knowledge and concepts.
Otherwise these general pages would clutter up all your other discovery features.
Ex. A mathematician searching for things related to pi getting results like:
serendipity pickups for sale in Tampa Getting started with raspberry PI My unique special idea about Pi that was the result of weeks of racking my brain My initial though, perhaps because I&amp;rsquo;m still affected by the collectors fallacy, was that I could handle this with categorization or tags and narrowing general things out or narrowing just to concepts.</description></item><item><title>Simple Haskell</title><link>https://paretooptimaldev.github.io/simple-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/simple-haskell/</guid><description>NOTE: lots of links you can tell should be in here aren&amp;rsquo;t yet.
history First Michael Snoyman posted about &amp;ldquo;boring haskell&amp;rdquo;, then some others sort of co-opted it, added bits of their own brand of simplicity, and marketed it as &amp;ldquo;simple haskell&amp;rdquo;.
What is it As opposed to &amp;ldquo;Fancy Haskell&amp;rdquo;, also see simple haskell vs fancy haskell
I believe part of my negative reaction to &amp;ldquo;simple haskell&amp;rdquo; is rooted in how much it gets in the way declarative programming.</description></item><item><title>the original quote that got me thinking about pareto optimality and software development</title><link>https://paretooptimaldev.github.io/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</guid><description>quote One could make a case that what we&amp;rsquo;re seeing here is that Haskell web frameworks, and probably a great deal more of the real Haskell code the community has produced in the past few years, is reaching the Pareto optimality frontier between ease-of-use and type safety guarantees.
I imagine a lot of people know what that is given where I am :), but in short, Pareto-optimal means that if you are optimizing between two quantities, you can not increase one without decreasing the other.</description></item><item><title>vscode</title><link>https://paretooptimaldev.github.io/vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/vscode/</guid><description/></item><item><title>worse is better</title><link>https://paretooptimaldev.github.io/worse-is-better/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://paretooptimaldev.github.io/worse-is-better/</guid><description>https://en.wikipedia.org/wiki/Worse%5Fis%5Fbetter
Also known as &amp;ldquo;New Jersey style&amp;rdquo;.
The Rise of ``Worse is Better''
Related Go Simple Haskell</description></item></channel></rss>