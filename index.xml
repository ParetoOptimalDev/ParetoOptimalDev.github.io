<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pareto Optimal Dev</title><link>https://www.paretooptimal.dev/</link><description>Recent content on Pareto Optimal Dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 May 2020 21:44:03 +0800</lastBuildDate><atom:link href="https://www.paretooptimal.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>"Simple Haskell" can result in simple code but complex codebases</title><link>https://www.paretooptimal.dev/simple-haskell-can-result-in-simple-code-but-complex-codebases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/simple-haskell-can-result-in-simple-code-but-complex-codebases/</guid><description>Related Prefer macro-level simplicity even if it means micro-level complexity Haskell</description></item><item><title>Best examples of real-world codebases in Haskell</title><link>https://www.paretooptimal.dev/best-examples-of-real-world-codebases-in-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/best-examples-of-real-world-codebases-in-haskell/</guid><description>https://github.com/typeable/octopod/ https://github.com/github/semantic https://github.com/jgm/pandoc</description></item><item><title>boring haskell</title><link>https://www.paretooptimal.dev/boring-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/boring-haskell/</guid><description/></item><item><title>brand of simplicity</title><link>https://www.paretooptimal.dev/brand-of-simplicity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/brand-of-simplicity/</guid><description>I find that most arguments about simplicity aren&amp;rsquo;t based in objective truth, but rather treat subjective ideas as objective fact in order to allow an argument to be stronger than it actually is.
So brand of simplicity is a way to:
indicate something being called simple isn&amp;rsquo;t necessarily simple encourage thinking about other values or vectors in which the subject wouldn&amp;rsquo;t be simple Push towards thinking about Pareto Optimality For instance the Go claimed for a very long term to not have parametric polymorphism &amp;ldquo;cuz simplicity&amp;rdquo;.</description></item><item><title>Categorizing state/quality of notes with tags and the real life tree lifecycle</title><link>https://www.paretooptimal.dev/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/categorizing-state/quality-of-notes-with-tags-and-the-real-life-tree-lifecycle/</guid><description>It can be useful to look at the &amp;ldquo;timelines&amp;rdquo;, &amp;ldquo;maturity of development&amp;rdquo;, or &amp;ldquo;doneness&amp;rdquo; of notes in an exobrain, zettlekasten, or digital garden given quality can vary widely.
Taking inspiration from Evergreen Notes we can use the following tree inspired cateories:
seed (aka stub elsewhere) stem sprout sapling tree evergreen This could be further augmented by using tags to delineate between polished and unpolished pieces of writing.
One example is an unpolished evergreen would have strong concepts and a well formed idea but the structure could be very messy or a little hard to follow.</description></item><item><title>Choosing "Fancy Haskell" can be for pragmatic reasons</title><link>https://www.paretooptimal.dev/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/choosing-fancy-haskell-can-be-for-pragmatic-reasons/</guid><description>stuff Related &amp;ldquo;Simple Haskell&amp;rdquo; can result in simple code but complex codebases Related Haskell</description></item><item><title>counteract my cognitive biases by playing devils advocate</title><link>https://www.paretooptimal.dev/counteract-my-cognitive-biases-by-playing-devils-advocate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/counteract-my-cognitive-biases-by-playing-devils-advocate/</guid><description/></item><item><title>Customizing devos after install for my use-cases</title><link>https://www.paretooptimal.dev/customizing-devos-after-install-for-my-use-cases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/customizing-devos-after-install-for-my-use-cases/</guid><description>continues from installing NixOS using devos and nix flakes make sure rebuilding works
bud rebuild $yourHostName switch Some weird nix error, but I see it&amp;rsquo;s to do with direnv issues with DevOS can be annoying, I know this is due to a previous workaround for direnv because of rapid development of Nix flakes while it&amp;rsquo;s not in NixOS by default.
There&amp;rsquo;s actually an issue to track this currently at divnix/devos#415 that I linked to in my commit fixing this.</description></item><item><title>develop Haskell projects using NixOS</title><link>https://www.paretooptimal.dev/develop-haskell-projects-using-nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/develop-haskell-projects-using-nixos/</guid><description/></item><item><title>Discoverable Emacs configuration for beginners based on Object->Action</title><link>https://www.paretooptimal.dev/discoverable-emacs-configuration-for-beginners-based-on-object-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/discoverable-emacs-configuration-for-beginners-based-on-object-action/</guid><description>This idea hit me while reading Fifteen ways to use embark when I realized how much easier having access to embark-act could make things for beginners.
This idea was furthered when reading the reddit thread about Discoverablity 2: Use context-menu-mode (since 28.1)&amp;hellip;.
Then other updates from Nicolas Rougier of Elegant Emacs that aims to clean up the emacs theme and UI had a couple posts that I thought of as being useful for this beginner configuration:</description></item><item><title>emacs</title><link>https://www.paretooptimal.dev/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/emacs/</guid><description/></item><item><title>Evergreen Notes</title><link>https://www.paretooptimal.dev/evergreen-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/evergreen-notes/</guid><description>Evergreen notes are written and organized to evolve, contribute, and accumulate over time, across projects. This is an unusual way to think about writing notes: Most people take only transient notes. That’s because these practices aren’t about writing notes; they’re about effectively developing insight: “Better note-taking” misses the point; what matters is “better thinking”. When done well, these notes can be quite valuable: Evergreen note-writing as fundamental unit of knowledge work.</description></item><item><title>examples of considering pareto optimality in software development</title><link>https://www.paretooptimal.dev/examples-of-considering-pareto-optimality-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/examples-of-considering-pareto-optimality-in-software-development/</guid><description>Ease of use and type-safety of Haskell programs quote from the original quote that got me thinking about pareto optimality and software development Arguably, ease-of-use and type safety could be such a case. For a long time the Haskell community has had a lot of places to get &amp;ldquo;free&amp;rdquo; gains in both dimensions. But, it should be expected that if you get enough of these gains squared away, that eventually you will hit the point where they will become tradeoffs.</description></item><item><title>flake-utils-plus</title><link>https://www.paretooptimal.dev/flake-utils-plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/flake-utils-plus/</guid><description>I&amp;rsquo;ve considered switching to this due to issues with DevOS, but just noticed it doesn&amp;rsquo;t support home-manager yet</description></item><item><title>Go</title><link>https://www.paretooptimal.dev/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/go/</guid><description>The programming language that was proud of not having generics in their language for most of the languages life.</description></item><item><title>Haskell</title><link>https://www.paretooptimal.dev/haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/haskell/</guid><description/></item><item><title>home-manager</title><link>https://www.paretooptimal.dev/home-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/home-manager/</guid><description>Frequently used in conjunction with NixOS, it allows users to encode their dotfiles in their nix configuration either inline or by files in their NixOS configuration</description></item><item><title>installing NixOS using devos and nix flakes</title><link>https://www.paretooptimal.dev/installing-nixos-using-devos-and-nix-flakes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/installing-nixos-using-devos-and-nix-flakes/</guid><description>Create a live usb with the latest NixOS 21.11 Download the recommended gnome version Follow instructions for Copying it to a usb stick but with a progress bar and larger block size So that means:
dd if=path-to-image of=/dev/sdX bs=4096 status=progress go for a short walk run the sync command to flush caches because I&amp;rsquo;m paranoid Boot into the live cd with no issues Wow Linux setup has come a long way!</description></item><item><title>issues with DevOS</title><link>https://www.paretooptimal.dev/issues-with-devos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/issues-with-devos/</guid><description>I&amp;rsquo;m tracking these because I&amp;rsquo;ve lost some time due to instability around updates and considered moving to flake-utils-plus which offers less features but might be more stable.</description></item><item><title>JUST SHIP IT!</title><link>https://www.paretooptimal.dev/just-ship-it/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/just-ship-it/</guid><description/></item><item><title>Just write sql</title><link>https://www.paretooptimal.dev/just-write-sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/just-write-sql/</guid><description/></item><item><title>keep it simple stupid</title><link>https://www.paretooptimal.dev/keep-it-simple-stupid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/keep-it-simple-stupid/</guid><description/></item><item><title>Literate emacs configuration examples</title><link>https://www.paretooptimal.dev/literate-emacs-configuration-examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literate-emacs-configuration-examples/</guid><description>Amazing alhassy&amp;rsquo;s lifemacs tecosaur&amp;rsquo;s emacs doom config Protesilaos Stavrou&amp;rsquo;s emacs configuration resources A list of people&amp;rsquo;s nice emacs config files</description></item><item><title>Literature: "I'm begging y'all to stop making complicated layers on top of SQL and just write SQL." - @ghrmc</title><link>https://www.paretooptimal.dev/literature-im-begging-yall-to-stop-making-complicated-layers-on-top-of-sql-and-just-write-sql.-ghrmc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literature-im-begging-yall-to-stop-making-complicated-layers-on-top-of-sql-and-just-write-sql.-ghrmc/</guid><description>Basically &amp;ldquo;Just write sql&amp;rdquo;</description></item><item><title>Literature: Abusing org-roam as a personal CRM - r/emacs</title><link>https://www.paretooptimal.dev/literature-abusing-org-roam-as-a-personal-crm-r/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literature-abusing-org-roam-as-a-personal-crm-r/emacs/</guid><description>I&amp;rsquo;ve found myself wanting to have the ability to see how other people use computers more effectively without committing half an hour or so to a video. So I tried to make a very short video showing how I use org-roam as a personal CRM. It isn&amp;rsquo;t a mind-blowing use-case, it isn&amp;rsquo;t any complex elisp, it is just a window into how I use Emacs to solve a problem that needed solving.</description></item><item><title>Literature: Delivering with Haskell</title><link>https://www.paretooptimal.dev/literature-delivering-with-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literature-delivering-with-haskell/</guid><description>https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597</description></item><item><title>Literature: Emacs: from catching up to getting ahead - r/emacs</title><link>https://www.paretooptimal.dev/literature-emacs-from-catching-up-to-getting-ahead-r/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literature-emacs-from-catching-up-to-getting-ahead-r/emacs/</guid><description>emacs</description></item><item><title>Literature: Why You Should Buy Into the Emacs Platform - r/emacs</title><link>https://www.paretooptimal.dev/literature-why-you-should-buy-into-the-emacs-platform-r/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/literature-why-you-should-buy-into-the-emacs-platform-r/emacs/</guid><description>https://old.reddit.com/r/emacs/comments/9gucsu/why%5Fyou%5Fshould%5Fbuy%5Finto%5Fthe%5Femacs%5Fplatform/
comment: emacs more extensible than modern editors Pick a random modern IDE or editor (I&amp;rsquo;ve tried with Atom, VSCode, Pycharm). Try to get it to: On startup (or easy mode - ever) open four terminals, space them in four windows, and when you execute commands in them allow reverse searching and pasting of the output history in the same way you navigate your code (for me, evil-mode).
None of them can do it, if you read the issues/source for VScode it doesn&amp;rsquo;t use a universal concept of windows/buffers, so the terminal is implemented in a &amp;ldquo;panel&amp;rdquo; which can&amp;rsquo;t be arbitrarily split, moved, edited in the same way as your code buffers.</description></item><item><title>major cognitive biases in software development</title><link>https://www.paretooptimal.dev/major-cognitive-biases-in-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/major-cognitive-biases-in-software-development/</guid><description/></item><item><title>Managing your emacs configuration, system configuration, and all dependencies in a single org file</title><link>https://www.paretooptimal.dev/managing-your-emacs-configuration-system-configuration-and-all-dependencies-in-a-single-org-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/managing-your-emacs-configuration-system-configuration-and-all-dependencies-in-a-single-org-file/</guid><description>WIP, this is just an outline so far
TODO Bootstrapping init.el to use an org file for what it believes is your &amp;ldquo;emacs configuration&amp;rdquo; TODO user level configuration using home-manager TODO configuring magit, including git as a system dependency, and .gitconfig in the same org heading</description></item><item><title>Nix flakes</title><link>https://www.paretooptimal.dev/nix-flakes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/nix-flakes/</guid><description>resources https://www.tweag.io/blog/2020-05-25-flakes/ https://serokell.io/blog/practical-nix-flakes (pretty accessible imo)</description></item><item><title>NixOS</title><link>https://www.paretooptimal.dev/nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/nixos/</guid><description/></item><item><title>NixOS configuration</title><link>https://www.paretooptimal.dev/nixos-configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/nixos-configuration/</guid><description>I&amp;rsquo;ll typically assume this means using Nix flakes, unless I think it&amp;rsquo;s 100% necessary to default to old-style non-flake configurations for accessibility such as in Package management and configuration in emacs where the audience might have never used NixOS.</description></item><item><title>NixOS has a steep learning curve</title><link>https://www.paretooptimal.dev/nixos-has-a-steep-learning-curve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/nixos-has-a-steep-learning-curve/</guid><description/></item><item><title>org-roam</title><link>https://www.paretooptimal.dev/org-roam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/org-roam/</guid><description/></item><item><title>Package management and configuration in emacs</title><link>https://www.paretooptimal.dev/package-management-and-configuration-in-emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/package-management-and-configuration-in-emacs/</guid><description>What&amp;rsquo;s the best way to manage packages in emacs? I&amp;rsquo;ve tried quite a few and prefer
package.el (builtin) I used this until I ran into two problems:
Using packages not yet in elpa or melpa easily from github &amp;ldquo;https://elpa.gnu.org/packages/archive-contents&amp;rdquo; &amp;ldquo;Bad Request&amp;rdquo; Maybe now there are better solutions, but I moved on to straight.el.
Sometimes I think about returning because I&amp;rsquo;ve found sticking to base packages that closely follow emacs conventions seems to make debugging and maintaining my configuration easier for some reason.</description></item><item><title>Pareto Optimality and software development</title><link>https://www.paretooptimal.dev/pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/pareto-optimality-and-software-development/</guid><description>Some may want to skip to examples of considering pareto optimality in software development
context In brief, Pareto optimal solution is defined as a set of &amp;lsquo;non-inferior&amp;rsquo; solutions in the objective space defining a boundary beyond which none of the objectives can be improved without sacrificing at least one of the other objectives - https://www.sciencedirect.com/topics/engineering/pareto-optimality
In the context of software development, you&amp;rsquo;ll frequently hear about tradeoffs such as the adage:</description></item><item><title>Personal Knowledge Management</title><link>https://www.paretooptimal.dev/personal-knowledge-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/personal-knowledge-management/</guid><description/></item><item><title>Prefer macro-level simplicity even if it means micro-level complexity</title><link>https://www.paretooptimal.dev/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/prefer-macro-level-simplicity-even-if-it-means-micro-level-complexity/</guid><description>Related Haskell</description></item><item><title>Principle of Charity</title><link>https://www.paretooptimal.dev/principle-of-charity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/principle-of-charity/</guid><description/></item><item><title>Provisioning a sample database along with postgres in nixos</title><link>https://www.paretooptimal.dev/provisioning-a-sample-database-along-with-postgres-in-nixos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/provisioning-a-sample-database-along-with-postgres-in-nixos/</guid><description>TODO</description></item><item><title>Replacing straight.el with Nix to manage emacs packages</title><link>https://www.paretooptimal.dev/replacing-straight.el-with-nix-to-manage-emacs-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/replacing-straight.el-with-nix-to-manage-emacs-packages/</guid><description>Why? In short, for better reproducability and to free me from manual intervention because packages broke later.
For more details you can see my history of package.el -&amp;gt; straight.el -&amp;gt; Nix for managing emacs packages in Package management and configuration in emacs.
The simple case straight.el configuration early-init.el
(setq package-enable-at-startup nil) init.el
(defvar bootstrap-version) (let ((bootstrap-file (expand-file-name &amp;#34;straight/repos/straight.el/bootstrap.el&amp;#34; user-emacs-directory)) (bootstrap-version 5)) (unless (file-exists-p bootstrap-file) (with-current-buffer (url-retrieve-synchronously &amp;#34;https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el&amp;#34; &amp;#39;silent &amp;#39;inhibit-cookies) (goto-char (point-max)) (eval-print-last-sexp))) (load bootstrap-file nil &amp;#39;nomessage)) (setq straight-use-package-by-default t) (straight-use-package &amp;#39;use-package) (use-package magit) nix configuration From NixOS early-init.</description></item><item><title>Should org-roam/zettlekasten be used only for concepts or also for more general data?</title><link>https://www.paretooptimal.dev/should-org-roam/zettlekasten-be-used-only-for-concepts-or-also-for-more-general-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/should-org-roam/zettlekasten-be-used-only-for-concepts-or-also-for-more-general-data/</guid><description>I suppose if you&amp;rsquo;re following zettlekasten or especially Evergreen Notes, it&amp;rsquo;ll be more about developing knowledge and concepts.
Otherwise these general pages would clutter up all your other discovery features.
Ex. A mathematician searching for things related to pi getting results like:
serendipity pickups for sale in Tampa Getting started with raspberry PI My unique special idea about Pi that was the result of weeks of racking my brain My initial though, perhaps because I&amp;rsquo;m still affected by the collectors fallacy, was that I could handle this with categorization or tags and narrowing general things out or narrowing just to concepts.</description></item><item><title>Simple Haskell</title><link>https://www.paretooptimal.dev/simple-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/simple-haskell/</guid><description>NOTE: lots of links you can tell should be in here aren&amp;rsquo;t yet.
history First Michael Snoyman posted about &amp;ldquo;boring haskell&amp;rdquo;, then some others sort of co-opted it, added bits of their own brand of simplicity, and marketed it as &amp;ldquo;simple haskell&amp;rdquo;.
What is it As opposed to &amp;ldquo;Fancy Haskell&amp;rdquo;, also see simple haskell vs fancy haskell
I believe part of my negative reaction to &amp;ldquo;simple haskell&amp;rdquo; is rooted in how much it gets in the way declarative programming.</description></item><item><title>Static type systems should be the default in computer programming</title><link>https://www.paretooptimal.dev/static-type-systems-should-be-the-default-in-computer-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/static-type-systems-should-be-the-default-in-computer-programming/</guid><description/></item><item><title>text user interfaces are faster than graphic interfaces</title><link>https://www.paretooptimal.dev/text-user-interfaces-are-faster-than-graphic-interfaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/text-user-interfaces-are-faster-than-graphic-interfaces/</guid><description>For example, magit in emacs versus sourcetree TODO test if this is true</description></item><item><title>the original quote that got me thinking about pareto optimality and software development</title><link>https://www.paretooptimal.dev/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/the-original-quote-that-got-me-thinking-about-pareto-optimality-and-software-development/</guid><description>quote One could make a case that what we&amp;rsquo;re seeing here is that Haskell web frameworks, and probably a great deal more of the real Haskell code the community has produced in the past few years, is reaching the Pareto optimality frontier between ease-of-use and type safety guarantees.
I imagine a lot of people know what that is given where I am :), but in short, Pareto-optimal means that if you are optimizing between two quantities, you can not increase one without decreasing the other.</description></item><item><title>vscode</title><link>https://www.paretooptimal.dev/vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/vscode/</guid><description/></item><item><title>Which Haskell database library manages complexity best in 2022?</title><link>https://www.paretooptimal.dev/which-haskell-database-library-manages-complexity-best-in-2022/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/which-haskell-database-library-manages-complexity-best-in-2022/</guid><description>Now that I&amp;rsquo;ve used Esqueleto professionally in anger, I would understand anyone who used it and then swore off static types forever. - @ttuegel
Seeing this quote got me thinking about writing this very node again since I:
frequently use Esqueleto have used Beam in the past have looked on longingly at rel8 (built on top of Opaleye) Recently annoyed with complexity while trying to teach others to use soon to be default Esqueleto.</description></item><item><title>Why pick emacs over vscode?</title><link>https://www.paretooptimal.dev/why-pick-emacs-over-vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/why-pick-emacs-over-vscode/</guid><description>Pick a random modern IDE or editor (I&amp;rsquo;ve tried with Atom, VSCode, Pycharm). Try to get it to: On startup (or easy mode - ever) open four terminals, space them in four windows, and when you execute commands in them allow reverse searching and pasting of the output history in the same way you navigate your code (for me, evil-mode).
None of them can do it, if you read the issues/source for VScode it doesn&amp;rsquo;t use a universal concept of windows/buffers, so the terminal is implemented in a &amp;ldquo;panel&amp;rdquo; which can&amp;rsquo;t be arbitrarily split, moved, edited in the same way as your code buffers.</description></item><item><title>worse is better</title><link>https://www.paretooptimal.dev/worse-is-better/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.paretooptimal.dev/worse-is-better/</guid><description>https://en.wikipedia.org/wiki/Worse%5Fis%5Fbetter
Also known as &amp;ldquo;New Jersey style&amp;rdquo;.
The Rise of ``Worse is Better''
Related Go Simple Haskell</description></item></channel></rss>